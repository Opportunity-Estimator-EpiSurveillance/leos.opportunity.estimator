{
    "collab_server" : "",
    "contents" : "#' @importFrom stringi stri_sub\n#' @importFrom grDevices colorRampPalette dev.off svg\n#' @importFrom graphics abline axis barplot hist lines plot polygon text\n#' @importFrom stats na.exclude quantile rnbinom\n#' @importFrom utils write.csv write.table\nNULL\n#' @import RColorBrewer scales\nNULL\n#' @include episem.R lastepiweek.R generate.estimates.R post.thresholds.R post.sum.R\nNULL\n\n#' Method to generate estimates based on notification opportunity profile.\n#'\n#' Function \\code{leos_method} applies the following method for the estimates:\n#' Notification delay modelling\n#' Leo Bastos\n#'\n#' N_t - number of notified cases at time t\n#' Y_{t,d} - number of notified cases from time t with notification delay d\n#' D - maximum acceptable time delay\n\n#' N_t = Y_{t,0} + sum_{d=1}^{D} Y_{t,d}\n\n#' Y_{0,t} is known forall t\n#' If T is today, Y_{t,d} is unknown for all (t,d) such that t+d > T\n\n#' Contributtors\n#' Claudia T Codeço and Marcelo F C Gomes\n#'\n#' @name apply.leos.method\n#'\n#' @param df.in Data frame with the FIRST THREE columns refering to [,1] location id, [,2] notification date,\n#'   [,3] digitization date.\n#' @param current.epiyearweek Most recent epidemiological week to be considered and estimated.\n#'   Expected format YYYY*WW, e.g., 2010W03\n#' @param quantile.target Quantile to be used to determine Dmax from delay profile. Default: 0.95\n#' @param low.activity List of location id's not to be estimated due to low activity. Default: NULL\n#'\n#' @author Marcelo F C Gomes \\email{marcelo.gomes@@fiocruz.br}\n#'\n#' @examples\n#' data(opportunity.exmaple.data)\n#' apply.leos.method(opportunity.example.data, current.epiyearweek='2014W52', quantile.target=0.95)\n#'\n#' @export\n\napply.leos.method <- function(df.in, current.epiyearweek, quantile.target=.95, low.activity=NULL){\n\n  d <- df.in[,1:3]\n  names(d) <- c('ID_MUNICIP', 'DT_NOTIFIC', 'DT_DIGITA')\n  current.epiweek <- as.integer(stri_sub(current.epiyearweek, -2, -1))\n  current.epiyear <- as.integer(stri_sub(current.epiyearweek, 1, 4))\n\n  # Create columns with epiweek, epiyear, and epiyearweek for notification and digitalization ones:\n  d <- cbind(d, t(sapply(d$DT_NOTIFIC,generate.columns.from.date)))\n  names(d) <- sub(\"^epi\", \"DT_NOTIFIC_epi\", names(d))\n  d <- cbind(d, t(sapply(d$DT_DIGITA,generate.columns.from.date)))\n  names(d) <- sub(\"^epi\", \"DT_DIGITA_epi\", names(d))\n\n  # Unlist new columns:\n  for (c in grep('epi', names(d), value=TRUE)){\n    d[[c]] <- unlist(d[[c]])\n  }\n\n  # Discar incomplete data from the current week for estimation:\n  d <- d[d$DT_DIGITA_epiyear < current.epiyear | (d$DT_DIGITA_epiyear==current.epiyear & d$DT_DIGITA_epiweek<=current.epiweek), ]\n\n  # Aggregate weekly data:\n  d_weekly <- data.frame(table(d$ID_MUNICIP, d$DT_NOTIFIC_epiyearweek))\n  names(d_weekly) <- c('ID_MUNICIP', 'DT_NOTIFIC_epiyearweek', 'CASOS_NOTIFIC')\n  d_weekly$epiweek <- mapply(function (x) as.integer(strsplit(as.character(x[[1]]), 'W')[[1]][2]),\n                                                         d_weekly$DT_NOTIFIC_epiyearweek)\n  d_weekly$epiyear <- mapply(function (x) as.integer(strsplit(as.character(x[[1]]), 'W')[[1]][1]),\n                                                         d_weekly$DT_NOTIFIC_epiyearweek)\n  # # Fill all epiweeks:\n  fyear <- min(d_weekly$epiyear)\n  years.list <- c(fyear:current.epiyear)\n  df.epiweeks <- data.frame(DT_NOTIFIC_epiyearweek=character(), UF=factor())\n  # List of locations:\n  mun_list <- unique(d_weekly$ID_MUNICIP)\n  for (y in years.list){\n    epiweeks <- c()\n    lweek <- ifelse(y < current.epiyear, as.integer(lastepiweek(y)), current.epiweek)\n    for (w in c(1:lweek)){\n      epiweeks <- c(epiweeks, paste0(y,'W',sprintf('%02d', w)))\n    }\n    for (mun in mun_list){\n      df.epiweeks <- rbind(df.epiweeks, data.frame(list(DT_NOTIFIC_epiyearweek=epiweeks, ID_MUNICIP=mun)))\n    }\n  }\n\n  d_weekly <- merge(df.epiweeks, d_weekly, by=c('DT_NOTIFIC_epiyearweek', 'ID_MUNICIP'), all.x=T)\n  d_weekly[is.na(d_weekly$epiweek), 'epiweek'] <- mapply(function (x) as.integer(strsplit(as.character(x[[1]]), 'W')[[1]][2]),\n                                                         d_weekly[is.na(d_weekly$epiweek), 'DT_NOTIFIC_epiyearweek'])\n  d_weekly[is.na(d_weekly$epiyear), 'epiyear'] <- mapply(function (x) as.integer(strsplit(as.character(x[[1]]), 'W')[[1]][1]),\n                                                         d_weekly[is.na(d_weekly$epiyear), 'DT_NOTIFIC_epiyearweek'])\n\n  d_weekly[is.na(d_weekly)] <- 0\n  d_weekly$Situation <- 'stable'\n  d_weekly[,c(\"mean\",\"50%\",\"2.5%\",\"97.5%\")] <- d_weekly$CASOS_NOTIFIC\n\n  # Calculate opportunity between notification and upload:\n  d$DelayWeeks <- d$DT_DIGITA_epiweek - d$DT_NOTIFIC_epiweek +\n    (d$DT_DIGITA_epiyear - d$DT_NOTIFIC_epiyear)*as.integer(sapply(d$DT_NOTIFIC_epiyear,lastepiweek))\n\n  # Discard notifications with delay greater than 6 months (> 26 weeks)\n  d <- na.exclude(d[d$DelayWeeks < 27, ])\n\n  # Grab target quantile from delay distribution for each UF\n  delay.topquantile <- c(ceiling(with(d, tapply(DelayWeeks, ID_MUNICIP, FUN = function(x,...) max(8,quantile(x,...)),\n                                                probs=quantile.target))))\n\n  # Check if plot folder exists\n  if (!dir.exists('./plots')) {\n    dir.create(file.path('./plots'), showWarnings = FALSE)\n  }\n  # Load palette\n  cores <- colorRampPalette((RColorBrewer::brewer.pal(9, 'Oranges')))(27)\n\n  # Prepare filled epiweeks data frame:\n  # # Fill all epiweeks:\n  fyear <- min(d$DT_NOTIFIC_epiyear)\n  years.list <- c(fyear:current.epiyear)\n  df.epiweeks <- data.frame(DT_NOTIFIC_epiyearweek=character())\n  for (y in years.list){\n    epiweeks <- c()\n    lweek <- ifelse(y < current.epiyear, as.integer(lastepiweek(y)), current.epiweek)\n    for (w in c(1:lweek)){\n      epiweeks <- c(epiweeks, paste0(y,'W',sprintf('%02d', w)))\n    }\n    df.epiweeks <- rbind(df.epiweeks, data.frame(list(DT_NOTIFIC_epiyearweek=epiweeks)))\n  }\n  rownames(df.epiweeks) <- df.epiweeks$DT_NOTIFIC_epiyearweek\n\n  # List of locations:\n  mun_list <- unique(d$ID_MUNICIP)\n\n  for (mun in mun_list){\n    if (!dir.exists(file.path('./plots',mun))) {\n      dir.create(file.path('./plots',mun), showWarnings = FALSE)\n    }\n\n\n    # Plot UF's delay distribution\n    qthreshold <- delay.topquantile[as.character(mun)]\n    d.tmp <- droplevels(subset(d, ID_MUNICIP==mun))\n    svg(paste0('./plots/',mun,'/delay_pattern.svg'))\n    histo <- hist(d.tmp$DelayWeeks, breaks=c(-1:27), plot=F)\n    barplot.fig <- barplot(histo$density, xlab = \"Delay (weeks)\", ylab = \"Notifications frequency\",\n                           xaxs='i', yaxs='i')\n    abline(v=barplot.fig[qthreshold+1], col='gray')\n    axis(1, at = barplot.fig, labels = c(0:(length(barplot.fig)-1)))\n    text(x=barplot.fig[qthreshold+1], y=.55*max(histo$density), 'Dmax', srt=90, pos=2)\n    dev.off()\n\n    # Prepare delay table\n    aux <- tapply(d.tmp$DelayWeeks >= 0, INDEX = list(d.tmp$DT_NOTIFIC_epiyearweek), FUN = sum, na.rm = T)\n    delay.tbl.tmp <- data.frame(Notifications = aux[order(rownames(aux))])\n\n    for(k in 0:26){\n      aux <- tapply(d.tmp$DelayWeeks == k, INDEX = d.tmp$DT_NOTIFIC_epiyearweek, FUN = sum, na.rm = T)\n      delay.tbl.tmp[paste(\"d\",k, sep=\"\")] <- aux[order(rownames(aux))]\n    }\n\n    delay.tbl.tmp <- merge(df.epiweeks, delay.tbl.tmp, by=0, all.x=T)\n    delay.tbl.tmp[is.na(delay.tbl.tmp)] <- 0\n    rownames(delay.tbl.tmp) <- delay.tbl.tmp$Row.names\n\n    # Plot UF's time series\n    svg(paste0('./plots/',mun,'/timeseries.svg'))\n    # # Time series\n    fyear = min(d.tmp$DT_NOTIFIC_epiyear)\n    plot(delay.tbl.tmp$Notifications , type = \"l\", axes=F, xlab=\"Time\", ylab=\"Notifications\")\n    axis(2)\n    axis(1, at = seq(0,52*(current.epiyear-fyear+1),52) ,labels = fyear:(current.epiyear+1))\n    dev.off()\n\n    # Plot time series with delay profile\n    svg(paste0('./plots/',mun,'/delay_timeseries.svg'))\n    delay.week <- paste(\"d\",0:26, sep=\"\")\n    barplot.fig <- barplot(t(as.matrix(delay.tbl.tmp[,delay.week])), beside = F, col=cores, axisnames = F,\n                           xlab  =  \"Time\", ylab = \"Notifications\", border = NA)\n    lines(x=barplot.fig,y=delay.tbl.tmp$d0, type = \"l\")\n    axis(1, at = barplot.fig[seq(1,53*(current.epiyear-fyear+1),52)] , labels = c(fyear:(current.epiyear+1)) )\n    #legend(x='topright', legend = c(seq(0,25,5)), fill=cores[seq(1,26,5)], pch = '.')\n    dev.off()\n\n    ##################################################################\n    # Preparing the data to be modelled\n    ##################################################################\n\n    # Time index of the unknown counts (Dmax+1,...,Tactual)\n    mun.indexes <- rownames(d_weekly[d_weekly$ID_MUNICIP==as.character(mun),])\n    Tactual <- length(mun.indexes)\n    index.time <- mun.indexes[(Tactual-qthreshold+1):Tactual]\n\n    if (!(mun %in% low.activity)) {\n\n      # Calculate estimates\n      df.tbl.tmp.estimates <- generate.estimates(delay.tbl.tmp, Dmax=qthreshold, do.plots=T, uf=mun)\n\n      # Generate quantiles estimates\n      aux2 <- round(t(apply(df.tbl.tmp.estimates$samples,1,FUN = post.sum)))\n\n      # # Calculate corresponding incidence\n      # years <- d_weekly[index.time, 'epiyear']\n      # pop <- sapply(years, FUN=function(x) d_pop$Total[d_pop$`Código`==mun & d_pop$Ano==x])\n      # aux2 <- aux2*100000/pop\n\n      # For estimated region, update with obtained predictions\n      d_weekly[index.time, 'Situation'] <- 'estimated'\n      d_weekly[index.time,colnames(aux2)] <- aux2\n\n      # # Calculate probability of falling in each activity region\n      # # Obtain location's thresholds\n      # mun.threshold <- as.numeric(df.thresholds[df.thresholds$ID_MUNICIP == as.character(mun), c(\"limiar pré-epidêmico\",\n      #                                                                                  \"intensidade alta\",\n      #                                                                                  \"intensidade muito alta\")])\n      # mun.threshold.absolute <- mun.threshold*d_pop[d_pop[,'Código']==mun & d_pop$Ano==current.epiyear, 'Total']/100000\n      # d_weekly[index.time,thres.prob.cols] <- t(apply(df.tbl.tmp.estimates$samples,1,FUN = post.thresholds, lims = mun.threshold.absolute ))\n\n    } else {\n      d_weekly[index.time, 'Situation'] <- 'unknown'\n    }\n\n  }\n\n  d_weekly[,'Run date'] <- Sys.Date()\n  df.Dmax <- data.frame(list(ID_MUNICIP=names(delay.topquantile), epiyearweek=current.epiyearweek, Dmax=delay.topquantile, Execution=Sys.Date()))\n\n  return(list(estimated.data.frame=d_weekly, delay.cutoff=df.Dmax))\n}\n",
    "created" : 1485885701388.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1470933906",
    "id" : "39010AE6",
    "lastKnownWriteTime" : 1485891665,
    "last_content_update" : 1485891665599,
    "path" : "~/codes/opportunity_estimator/leos.opportunity.estimator/R/apply.leos.method.R",
    "project_path" : "R/apply.leos.method.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}