{
    "collab_server" : "",
    "contents" : "#' @import INLA\nNULL\n#' Function to generate INLA estimates\n#'\n#' Function \\code{generate.estimates} applies Leo's Method to a table with counts and delays\n#'\n#' @name generate.estimates\n#'\n#' @param delay.tbl.tmp Table with at least Dmax+1 columns. First column is the total count,\n#'   followed by counts with delay 0, 1, 2, ...\n#' @param Dmax Maximum delay to be taken into account\n#' @param do.plots Wether to generate plots or not. Default: F\n#' @param uf ID for plot folder. Default: 'tmp'\n#'\n#' @keywords internal\n#' @author Leo Bastos\n\ngenerate.estimates <- function(delay.tbl.tmp, Dmax, do.plots=F, uf='tmp'){\n\n  # Generate etimates for the previous Dmax weeks based on notification oportunity profile\n  # found in delay.tbl.tmp\n  delay.week <- paste0(\"d\",0:Dmax)\n  delay.tbl.tmp <- delay.tbl.tmp[delay.week]\n\n  # tempo máximo do banco\n  Tmax <- nrow(delay.tbl.tmp)\n\n  # Última semana no banco\n  Tactual <- dim(delay.tbl.tmp)[1]\n\n  delay.tbl.tmp.obs <- delay.tbl.tmp[1:Tactual,(0:Dmax)+1]\n\n  # Time index of the unknown counts (Dmax+1,...,Tactual)\n  index.time <- (Tactual-Dmax+1):Tactual\n\n\n  delay.tbl.tmp.obs.trian <- delay.tbl.tmp.obs\n\n  # Creating the run-off triangle data frame\n  delay.tbl.tmp.obs.trian[outer(1:Tactual, 0:Dmax, FUN = \"+\") > Tactual] <- NA\n\n  # This function creates a data frame from the run-off triangle matrix to be used in INLA\n  make.df.trian <- function(M){\n    Time <- nrow(M)\n    Delay <- ncol(M)\n    aux.df <- data.frame(Y = as.vector(as.matrix(M)),\n                         Time = rep(x = 1:Time, times = Delay),\n                         Delay = rep(x = 0:(Delay-1), each=Time)\n    )\n    aux.df\n  }\n\n  # A <- data.frame(matrix(1:12, nrow=3))\n  # as.vector(as.matrix(A))\n  # make.df.trian(A)\n\n  # Creating a data frame for INLA\n  delay.inla.trian <- make.df.trian(delay.tbl.tmp.obs.trian)\n\n  # Find the missing values\n  index.missing <- which(is.na(delay.inla.trian$Y))\n\n  # Equacao do modelo: intercepto + efeito_de_tempo + efeito_de_oportunidade!!!\n  model <- Y ~ 1 +\n    f(Time, model = \"rw1\", hyper = list(\"prec\" = list(prior = \"loggamma\", param = c(0.001, 0.001)))) +\n    f(Delay, model = \"rw1\", hyper = list(\"prec\" = list(prior = \"loggamma\", param = c(0.001, 0.001))))\n\n\n  # model.ar <- Y ~ 1 +\n  #   f(Time, model = \"ar1\", hyper = list(\n  #     \"prec\" = list(prior = \"loggamma\", param = c(0.001, 0.001)),\n  #     \"rho\" = list(prior = \"normal\", param = c(0, 0.2)))\n  #    ) +\n  #   f(Delay, model = \"rw1\", hyper = list(\"prec\" = list(prior = \"loggamma\", param = c(0.001, 0.001))))\n\n  # ajuste, verossimilhanca binomial negativa\n  output <- inla(model, family = \"nbinomial\", data = delay.inla.trian,\n                 control.predictor = list(link = 1, compute = T),\n                 control.compute = list( config = T, waic=TRUE, dic=TRUE),\n                 control.family = list(\n                   hyper = list(\"theta\" = list(prior = \"loggamma\", param = c(0.1, 0.1)))\n                 )\n  )\n\n\n  # criterios de comparacao de modelo, só são uteis se estivermos comparando modelos!\n  # c(WAIC = output$waic$waic, DIC = output$dic$dic)\n\n  # Resumo dos hiperparametros\n  #output$summary.hyperpar\n\n  if (do.plots == T){\n    plot.inla.re = function(outputRE, x = outputRE$ID){\n      plot( x, y = outputRE$mean, type = \"n\", ylim = range(outputRE[,c(4,6)]), ylab=\"\", xlab=\"\" )\n      polygon(x = c(x, rev(x)),\n              y = c(outputRE$'0.025quant', rev(outputRE$'0.975quant')),\n              border = \"black\", col = \"gray\")\n      lines(x, outputRE$mean, lty=1, lwd=2)\n      lines(x = range(x), y = rep(0,2), lty=2)\n    }\n\n    svg(paste0('./plots/',uf,'/time_effect.svg'))\n    plot.inla.re(output$summary.random$Time)\n    dev.off()\n\n    svg(paste0('./plots/',uf,'/delay_effect.svg'))\n    plot.inla.re(output$summary.random$Delay)\n    dev.off()\n\n  }\n\n\n  # Gerando amostras da posteriori dos parâmetros do modelo ajustado no INLA\n  delay.samples.list <- inla.posterior.sample(n = 250, output)\n\n\n\n  # Sampling the missing triangule from inla output in vector format from the model likelihood\n  aaa <- lapply(X = delay.samples.list, FUN = function(x, idx = index.missing) rnbinom(n = idx, mu = exp(x$latent[idx]), size = x$hyperpar[1]))\n\n\n  # Creating a vectorized version of the triangle matrix\n  delay.vec.trian <- inla.matrix2vector(as.matrix(delay.tbl.tmp.obs.trian[index.time,]))\n\n  # Transforming back from the vector form to the matrix form\n  bbb <- lapply(aaa, FUN = function(xxx, data = delay.vec.trian){\n    data[which(is.na(data))] <- xxx\n    inla.vector2matrix(data, ncol = Dmax+1) } )\n\n\n  # Samples of {N_t : t=Tactual-Dmax+1,...Tactual}\n  ccc <- sapply(bbb, FUN = function(x) rowSums(x) )\n\n  return(list(samples=ccc))\n}\n",
    "created" : 1485884903358.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4131373774",
    "id" : "4F33C8B7",
    "lastKnownWriteTime" : 1485886457,
    "last_content_update" : 1485886457400,
    "path" : "~/codes/opportunity_estimator/leos.opportunity.estimator/R/generate.estimates.R",
    "project_path" : "R/generate.estimates.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}